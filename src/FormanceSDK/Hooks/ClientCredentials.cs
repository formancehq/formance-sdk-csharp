//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace FormanceSDK.Hooks
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net.Http;
    using System.Security.Cryptography;
    using System.Threading.Tasks;
    using System.Text;
    using Newtonsoft.Json;
    using FormanceSDK.Models.Components;
    using FormanceSDK.Utils;

    public class TokenResponse
    {
        [JsonProperty("access_token")]
        public string? AccessToken { get; private set; }

        [JsonProperty("token_type")]
        public string? TokenType { get; private set; }

        [JsonProperty("expires_in")]
        public long? ExpiresIn { get; private set; }
    }

    public class Credentials
    {
        public string ClientID { get; private set; }
        public string ClientSecret { get; private set; }
        public string TokenURL { get; private set; }

        public Credentials(string clientID, string clientSecret, string tokenURL)
        {
            ClientID = clientID;
            ClientSecret = clientSecret;
            TokenURL = tokenURL;
        }
    }

    public class Session
    {
        public Credentials Credentials { get; private set; }
        public string Token { get; private set; }
        public List<string> Scopes { get; private set; }
        public DateTime? ExpiresAt { get; private set; }

        public Session(Credentials credentials, string token, List<string> scopes, DateTime? expiresAt = null)
        {
            Credentials = credentials;
            Token = token;
            Scopes = scopes;
            ExpiresAt = expiresAt;
        }
    }

    public class ClientCredentialsHook : ISDKInitHook, IBeforeRequestHook, IAfterErrorHook
    {
        public string BaseURL { get; private set; } = "";
        public Dictionary<string, Session> Sessions { get; private set; } = new Dictionary<string, Session>();
        public ISpeakeasyHttpClient Client;

        public (string, ISpeakeasyHttpClient) SDKInit(string baseUrl, ISpeakeasyHttpClient client)
        {
            BaseURL = baseUrl;
            Client = client;

            return (baseUrl, client);
        }

        public async Task<HttpRequestMessage> BeforeRequestAsync(BeforeRequestContext hookCtx, HttpRequestMessage request)
        {
            if (hookCtx.Oauth2Scopes == null)
            {
                // OAuth2 not in use
                return request;
            }

            var credentials = GetCredentials(hookCtx.SecuritySource);
            if (credentials == null)
            {
                return request;
            }

            var sessionKey = GetSessionKey(credentials.ClientID, credentials.ClientSecret);

            if (!Sessions.ContainsKey(sessionKey) || !HasRequiredScopes(Sessions[sessionKey].Scopes, hookCtx.Oauth2Scopes) || HasTokenExpired(Sessions[sessionKey].ExpiresAt))
            {
                var session = await DoTokenRequestAsync(
                    credentials,
                    GetScopes(hookCtx.Oauth2Scopes, Sessions.GetValueOrDefault(sessionKey))
                );

                Sessions[sessionKey] = session;
            }

            request.Headers.Remove("Authorization");
            request.Headers.Add("Authorization", $"Bearer {Sessions[sessionKey].Token}");

            return request;
        }

        #pragma warning disable CS1998
        public async Task<(HttpResponseMessage?, Exception?)> AfterErrorAsync(AfterErrorContext hookCtx, HttpResponseMessage? response, Exception? error)
        {
            if (hookCtx.Oauth2Scopes == null)
            {
                // OAuth2 not in use
                return (response, error);
            }

            if (error != null)
            {
                // We don't want to refresh the token if the error is not related to the token
                return (response, error);
            }

            var credentials = GetCredentials(hookCtx.SecuritySource);
            if (credentials == null)
            {
                return (response, error);
            }

            if (response != null && response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
            {
                var sessionKey = GetSessionKey(credentials.ClientID, credentials.ClientSecret);

                if (Sessions.ContainsKey(sessionKey))
                {
                    Sessions.Remove(sessionKey);
                }
            }

            return (response, error);
        }
        #pragma warning restore CS1998

        private Credentials? GetCredentials(Func<object>? securitySource)
        {
            if (securitySource == null)
            {
                return null;
            }

            Security? security = securitySource() as Security;

            if (security?.ClientID == null || security?.ClientSecret == null)
            {
                return null;
            }
            
            return new Credentials(
                security.ClientID,
                security.ClientSecret,
                security.TokenURL
            );
        }

        private async Task<Session> DoTokenRequestAsync(Credentials credentials, List<string> scopes)
        {
            var payload = new Dictionary<string, string>
            {
                { "grant_type", "client_credentials" },
                { "client_id", credentials.ClientID },
                { "client_secret", credentials.ClientSecret },
            };

            if (scopes.Count > 0)
            {
                payload.Add("scope", string.Join(" ", scopes));
            }

            Uri tokenUri;
            try
            {
                tokenUri = new Uri(new Uri(BaseURL), credentials.TokenURL);
            }
            catch (UriFormatException ex)
            {
                throw new Exception($"Failed to parse token URL: {ex}");
            }

            var request = new HttpRequestMessage
                {
                    Method = HttpMethod.Post,
                    RequestUri = tokenUri,
                    Content = new FormUrlEncodedContent(payload)
                };

            var response = await Client.SendAsync(request);
            var responseBody = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                throw new Exception($"Unexpected status code {response.StatusCode}: {responseBody}");
            }

            TokenResponse? tokenResponse;
            try
            {
                tokenResponse = JsonConvert.DeserializeObject<TokenResponse>(responseBody);
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to decode token response: {ex.Message}", ex);
            }

            if (tokenResponse == null)
            {
                throw new Exception("Failed to decode token response");
            }

            if (tokenResponse?.TokenType != "Bearer")
            {
                throw new Exception($"Unexpected token type {tokenResponse.TokenType}");
            }

            DateTime? expiresAt = null;
            if (tokenResponse?.ExpiresIn != null)
            {
                expiresAt = DateTime.Now.AddSeconds(tokenResponse.ExpiresIn.Value);
            }

            return new Session(credentials, tokenResponse?.AccessToken, scopes, expiresAt);
        }

        private string GetSessionKey(string clientID, string clientSecret)
        {
            using (MD5 md5 = MD5.Create())
            {
                byte[] hashBytes = md5.ComputeHash(Encoding.UTF8.GetBytes($"{clientID}:{clientSecret}"));
                return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
            }
        }

        private bool HasRequiredScopes(List<string> sessionScopes, List<string> requiredScopes)
        {
            return requiredScopes.All(requiredScope => sessionScopes.Contains(requiredScope));
        }

        private List<string> GetScopes(List<string> requiredScopes, Session? session)
        {
            if (session?.Scopes != null)
            {
                var scopes = new List<string>(requiredScopes);
                scopes.AddRange(session.Scopes);
                return scopes.Distinct().ToList();
            }

            return requiredScopes;
        }

        private bool HasTokenExpired(DateTime? expiresAt)
        {
            return expiresAt == null || DateTime.UtcNow.AddSeconds(60) >= expiresAt;
        }
    }
}