//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace FormanceSDK.Hooks.ClientCredentials
{
        using FormanceSDK.Models.Components;
        using FormanceSDK.Utils;
        using Newtonsoft.Json;
        using System;
        using System.Collections.Concurrent;
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Security.Cryptography;
        using System.Text;
        using System.Threading.Tasks;

    using PayloadValue = System.Collections.Generic.KeyValuePair<string?, string?>;

    public class TokenResponse
    {
        [JsonProperty("access_token")]
        public string AccessToken { get; private set; } = default!;

        [JsonProperty("token_type")]
        public string TokenType { get; private set; } = default!;

        [JsonProperty("expires_in")]
        public long? ExpiresIn { get; private set; }
    }

    public class Credentials
    {
        public string ClientID { get; private set; }
        public string ClientSecret { get; private set; }
        public string TokenURL { get; private set; }

        public Credentials(string clientID, string clientSecret, string tokenURL)
        {
            ClientID = clientID;
            ClientSecret = clientSecret;
            TokenURL = tokenURL;
        }
    }

    public class Session
    {
        public Credentials Credentials { get; private set; }
        public string Token { get; private set; }
        public List<string> Scopes { get; private set; }
        public DateTime? ExpiresAt { get; private set; }

        public Session(Credentials credentials, string token, List<string> scopes, DateTime? expiresAt = null)
        {
            Credentials = credentials;
            Token = token;
            Scopes = scopes;
            ExpiresAt = expiresAt;
        }
    }

    public class ClientCredentialsHook : ISDKInitHook, IBeforeRequestHook, IAfterErrorHook
    {
        public ConcurrentDictionary<string, Session> Sessions { get; private set; } = new ConcurrentDictionary<string, Session>();
        public ISpeakeasyHttpClient Client = default!;
        
        public (string, ISpeakeasyHttpClient) SDKInit(string baseUrl, ISpeakeasyHttpClient client)
        {
            Client = client;

            return (baseUrl, client);
        }
        
        public async Task<HttpRequestMessage> BeforeRequestAsync(BeforeRequestContext hookCtx, HttpRequestMessage request)
        {
            if (hookCtx.Oauth2Scopes == null)
            {
                // OAuth2 not in use
                return request;
            }

            var credentials = GetCredentials(hookCtx);
            if (credentials == null)
            {
                return request;
            }

            var sessionKey = GetSessionKey(credentials.ClientID, credentials.ClientSecret);

            if (!Sessions.ContainsKey(sessionKey) || !HasRequiredScopes(Sessions[sessionKey].Scopes, hookCtx.Oauth2Scopes) || HasTokenExpired(Sessions[sessionKey].ExpiresAt))
            {
                var session = await DoTokenRequestAsync(
                    hookCtx.BaseURL,
                    credentials,
                    GetScopes(hookCtx.Oauth2Scopes, Sessions.GetValueOrDefault(sessionKey))
                );

                Sessions[sessionKey] = session;
            }

            request.Headers.Remove("Authorization");
            request.Headers.Add("Authorization", $"Bearer {Sessions[sessionKey].Token}");

            return request;
        }

        #pragma warning disable CS1998
        public async Task<(HttpResponseMessage?, Exception?)> AfterErrorAsync(AfterErrorContext hookCtx, HttpResponseMessage? response, Exception? error)
        {
            if (hookCtx.Oauth2Scopes == null)
            {
                // OAuth2 not in use
                return (response, error);
            }

            if (error != null)
            {
                // We don't want to refresh the token if the error is not related to the token
                return (response, error);
            }

            var credentials = GetCredentials(hookCtx);
            if (credentials == null)
            {
                return (response, error);
            }

            if (response != null && response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
            {
                var sessionKey = GetSessionKey(credentials.ClientID, credentials.ClientSecret);
                Sessions.TryRemove(sessionKey, out _);
            }

            return (response, error);
        }
        #pragma warning restore CS1998

        private Credentials? GetCredentials(HookContext hookCtx)
        {

            if (hookCtx.SecuritySource == null)
            {
                return null;
            }

            return GetCredentialsGlobal(hookCtx.SecuritySource);
        }


        private Credentials? GetCredentialsGlobal(Func<object> securitySource)
        {
            var security = securitySource() as Security;

            if (security?.ClientID == null || security?.ClientSecret == null || security?.TokenURL == null)
            {
                return null;
            }

            return new Credentials(
                security?.ClientID!,
                security?.ClientSecret!,
                security?.TokenURL!
            );
        }

        private async Task<Session> DoTokenRequestAsync(string baseURL, Credentials credentials, List<string> scopes)
        {
            if( Client == null )
            {
                throw new Exception("SpeakeasyHttpClient not provided");
            }

            var payload = new List<PayloadValue>
            {
                new PayloadValue("grant_type", "client_credentials"),
                new PayloadValue("client_id", credentials.ClientID),
                new PayloadValue("client_secret", credentials.ClientSecret),
            };

            if (scopes.Count > 0)
            {
                payload.Add(new PayloadValue("scope", string.Join(" ", scopes)));
            }

            Uri tokenUri;
            try
            {
                tokenUri = new Uri(new Uri(baseURL), credentials.TokenURL);
            }
            catch (UriFormatException ex)
            {
                throw new Exception($"Failed to parse token URL: {ex}");
            }

            var request = new HttpRequestMessage
                {
                    Method = HttpMethod.Post,
                    RequestUri = tokenUri,
                    Content = new FormUrlEncodedContent(payload)
                };

            var response = await Client.SendAsync(request);
            var responseBody = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                throw new Exception($"Unexpected status code {response.StatusCode}: {responseBody}");
            }

            TokenResponse tokenResponse;
            try
            {
                TokenResponse? obj = JsonConvert.DeserializeObject<TokenResponse?>(responseBody);
                if (obj == null)
                {
                    throw new Exception("Token response is null.");
                }
                tokenResponse = obj;
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to decode token response: {ex.Message}", ex);
            }

            if (tokenResponse == null)
            {
                throw new Exception("Failed to decode token response");
            }

            if (!string.Equals(tokenResponse!.TokenType, "Bearer", StringComparison.OrdinalIgnoreCase))
            {
                throw new Exception($"Unexpected token type {tokenResponse!.TokenType}");
            }

            if (tokenResponse.AccessToken == null)
            {
                throw new Exception("Failed to retrieve access token");
            }

            DateTime? expiresAt = null;
            if (tokenResponse!.ExpiresIn != null)
            {
                expiresAt = DateTime.Now.AddSeconds(tokenResponse!.ExpiresIn!.Value);
            }

            return new Session(credentials, tokenResponse!.AccessToken, scopes, expiresAt);
        }

        private string GetSessionKey(string clientID, string clientSecret)
        {
            using (MD5 md5 = MD5.Create())
            {
                byte[] hashBytes = md5.ComputeHash(Encoding.UTF8.GetBytes($"{clientID}:{clientSecret}"));
                return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
            }
        }

        private bool HasRequiredScopes(List<string> sessionScopes, List<string> requiredScopes)
        {
            return requiredScopes.All(requiredScope => sessionScopes.Contains(requiredScope));
        }

        private List<string> GetScopes(List<string> requiredScopes, Session? session)
        {
            if (session?.Scopes != null)
            {
                var scopes = new List<string>(requiredScopes);
                scopes.AddRange(session.Scopes);
                return scopes.Distinct().ToList();
            }

            return requiredScopes;
        }

        private bool HasTokenExpired(DateTime? expiresAt)
        {
            return expiresAt == null || DateTime.UtcNow.AddSeconds(60) >= expiresAt;
        }
    }
}